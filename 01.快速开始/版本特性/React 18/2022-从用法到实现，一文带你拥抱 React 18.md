> [原文地址](https://juejin.cn/post/7095185674151821348#heading-14)

# 从用法到实现，一文带你拥抱 React 18

# 前言

React 团队在打造快速响应的用户界面上其实一直在探索，最终给出的答案就是整合了人机交互研究成果（后文会具体介绍）的 Concurrent Rendering。

然而因为这背后的复杂性、稳定性、兼容性等问题，从 16 版本的 Async Mode 开始就在不断打磨，耗时多年，经历了 17 版本过渡，最终伴随着 18 版本正式上线，这一版本中开发者可以完全平滑的开启并发特性。

今天希望通过这篇文章带大家一起深入了解一下 React 18 中的新特性、新能力。

# Concurrent Rendering

Concurrency 是 React 18 的关键词，可以理解成是一种背后的机制，保证 React 能够同时准备多套 UI。具体到表现上区别于以往的最大的特点就是渲染是可中断的。这意味着当你的应用正在进行复杂更新的时候，仍然可以与页面进行交互，保证一个流畅的用户体验。 既然是一种背后的机制，实际上开发者并非需要先学习并发渲染才能使用 React18，但是能够掌握并发渲染对于新特性的理解有非常大的作用。

核心实现是通过组件作为一个基本的工作单元将一个大的更新任务进行拆分，然后以时间切片的方式，分布在不同的时间片来执行，每个时间片执行完成后都会主动释放控制权，使得浏览器能够处理其它用户事件。而具体时间片上执行哪个任务是由任务上的相关优先级决定的，当高优先级的更新到来时，会中断旧的更新，优先执行高优先级更新，待完成后继续执行低优先级更新，因此在一个时间段内，我们看 React 在并发的执行多个渲染任务。

## Auto Batching

首先批处理是指 React 将多次状态更新合并成一次重渲染来提升性能，早在 16 的版本中其实就已经包含了批处理能力，如下面的例子：

```js
function App() {
  const [count, setCount] = useState(0);

  const [flag, setFlag] = useState(false);

  function handleClick() {
    setCount((c) => c + 1); // Does not re-render yet

    setFlag((f) => !f); // Does not re-render yet

    // React will only re-render once at the end (that's batching!)
  }

  return (
    <div>
      <button onClick={handleClick}>Next</button>

      <h1 style={{ color: flag ? "blue" : "black" }}>{count}</h1>
    </div>
  );
}
```

然而如果更新发生在 timeouts, promises, native event handlers 等非 React events 事件中，React 18 之前的版本默认都不会进行合并：

```js
function handleClick() {
  fetchSomething().then(() => {
    // React 17 and earlier does NOT batch these because

    // they run *after* the event in a callback, not *during* it

    setCount((c) => c + 1); // Causes a re-render

    setFlag((f) => !f); // Causes a re-render
  });
}
```

在 React 18 中，不会更新发生在哪里，都会自动合并。一般来说，这种自动合并是完全安全且无感知的，但是仍然有一些 bad case 需要特殊处理以保持向前兼容，比如下面的 case：

```js
handleClick = () => {
  setTimeout(() => {
    this.setState(({ count }) => ({ count: count + 1 }));

    // { count: 1, flag: false } before 18

    // { count: 0, flag: false } in 18

    console.log(this.state);

    this.setState(({ flag }) => ({ flag: !flag }));
  });
};
```

在 18 之前，由于更新会同步执行，因此我们能够获得中间状态。然而在 18 中，即使是 setTimeout 中的更新也会自动合并，并在 next tick 中合并执行，打印的状态为初始化状态，从而前后不一致。

针对这种情况，我们可以使用 React 18 中提供的 ReactDOM.flushSync 来保持向前兼容。

```js
handleClick = () => {
  setTimeout(() => {
    ReactDOM.flushSync(() => {
      this.setState(({ count }) => ({ count: count + 1 }));
    });

    // { count: 1, flag: false }

    console.log(this.state);

    this.setState(({ flag }) => ({ flag: !flag }));
  });
};
```

### Deep dive

自动批处理实现的关键在于 React18 中更新是基于优先级的，我们结合下面源码看一下，该方法是 18 中每一次更新调度的必经之路，批处理的实现的核心在于当相同优先级的更新发生时，并不会生成新的任务，而是复用上一次的任务，从而实现合并。

```js
function ensureRootIsScheduled(root: FiberRoot, currentTime: number) {
  // Determine the next lanes to work on, and their priority.

  const nextLanes = getNextLanes(root);

  // We use the highest priority lane to represent the priority of the callback.

  const newCallbackPriority = getHighestPriorityLane(nextLanes);

  // Check if there's an existing task. We may be able to reuse it.

  const existingCallbackPriority = root.callbackPriority;

  if (existingCallbackPriority === newCallbackPriority) {
    // The priority hasn't changed. We can reuse the existing task. Exit.

    return;
  }

  // Cancel the existing callback.

  cancelCallback(existingCallbackNode);

  // schedule a new one.

  if (newCallbackPriority === SyncLane) {
    scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));
  } else {
    newCallbackNode = scheduleCallback(
      schedulerPriorityLevel,

      performConcurrentWorkOnRoot.bind(null, root)
    );
  }
}
```

如果理解了这个，那个 FlushSync 的实现也就比较简单了，无非是将内部更新的优先级强制指定为 SyncLane，即指定为同步优先级，具体效果就是每一次更新时都会同步的执行渲染。

```js
export function flushSync(fn) {
  try {
    // DiscreteEventPriority === SyncLane

    setCurrentUpdatePriority(DiscreteEventPriority);

    fn && fn();
  } finally {
    setCurrentUpdatePriority(previousPriority);
  }
}
```

## Transition

transition 是 18 版本中新提出的概念，也是最能体现并发渲染优势的上层应用。先看一个例子，当滑块滑动时，下方的图表会一起更新，然而图表更新是一个 CPU 密集型操作，比较耗时。由于阻塞了渲染导致页面失去响应，用户能够非常明显的感受到卡顿。

![](https://ngte-superbed.oss-cn-beijing.aliyuncs.com/gif/14f828dc58f84e729acf6343bfcc7d7c%7Etplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.webp)

实际上，当我们拖动滑块的时候，需要做两次更新：

```js
// Urgent: Show what was typed
setSliderValue(input);

// Not urgent: Show the results
setGraphValue(input);
```

一个是比较紧急需要立刻反应在界面上，否则用户会觉得遇到了 bug。而另一个对于用户而言，查询结果的显示，即使存在一些延迟也是可接受的。这种接受程度正是人机研究的成果：

> we know from research that interactions like hover and text input need to be handled within a very short period of time, while clicks and page transitions can wait a little longer without feeling laggy. —— Putting Research into Production

在 React 18 之前所有的更新都是一样的，缺乏一种机制，来声明这种不同紧急程度的更新，Transition 就用来解决这种问题。React 18 中提供了 startTransition 来让开发者显示的声明非紧急更新。transition 取名的含义是，React 中从开发者角度将状态更新分成了两类：

- 一类是用户输入、点击等紧急更新，另一类是将 UI 从一个视图转变成另外一个
- transition 中对应的更新类型为第二种。

## startTransition
